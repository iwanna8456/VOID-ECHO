<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>VOID ECHO: Full Edition 2025</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Courier New', monospace; }
        canvas { display: block; image-rendering: pixelated; }
        #device-menu, #menu { position: absolute; width: 100%; height: 100%; background: #000; display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 100; color: white; text-align: center; border: 4px solid white; box-sizing: border-box; }
        #menu-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: -1; }
        .btn { padding: 15px 40px; font-size: 24px; background: black; color: white; border: 4px solid white; cursor: pointer; margin: 10px; position: relative; z-index: 101; font-family: inherit; }
        .btn:hover { background: white; color: black; }
        #seed-input { padding: 10px; font-size: 18px; margin-top: 20px; background: #111; color: white; border: 2px solid white; text-align: center; width: 250px; outline: none; }
        #hud { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); display: none; flex-direction: column; align-items: center; pointer-events: none; }
        #hearts { display: flex; margin-bottom: 10px; font-size: 28px; line-height: 28px; }
        .heart { color: #ff0000; margin: 0 3px; text-shadow: 0 0 5px rgba(255,0,0,0.5); }
        .heart.empty { color: #330000; text-shadow: none; }
        .heart.god { text-shadow: 0 0 10px #fff; }
        #hotbar { display: flex; background: rgba(0,0,0,0.8); border: 2px solid #fff; padding: 5px; pointer-events: auto; }
        .slot { width: 48px; height: 48px; border: 2px solid #444; margin: 0 4px; display: flex; align-items: center; justify-content: center; font-size: 24px; opacity: 0.3; }
        .slot.active { border-color: #fff; box-shadow: 0 0 15px #fff; opacity: 1 !important; }
        .slot.unlocked { opacity: 1; border-color: #666; }
        #status-ui { position: absolute; top: 10px; left: 10px; color: #0f0; font-weight: bold; font-size: 14px; text-shadow: 1px 1px #000; z-index: 10; }
        #seed-container { position: absolute; bottom: 10px; left: 10px; display: none; z-index: 10; font-size: 12px; color: rgba(255,255,255,0.5); }
        #seed-display-val { background: transparent; border: none; color: rgba(255,255,255,0.5); font-family: inherit; width: 150px; outline: none; }
        #side-panel { position: absolute; top: 10px; right: -210px; width: 250px; background: rgba(0, 0, 0, 0.8); border: 2px solid #fff; padding: 10px; transition: right 0.4s; z-index: 150; display: none; color: white; }
        #side-panel:hover { right: 10px; }
        #side-input { width: 100%; background: #111; color: #fff; border: 1px solid #fff; padding: 5px; box-sizing: border-box; font-family: inherit; }
        #mobile-controls { position: absolute; bottom: 30px; width: 100%; display: none; justify-content: space-between; padding: 0 40px; box-sizing: border-box; z-index: 200; pointer-events: none; }
        .joy-btn { width: 85px; height: 85px; background: rgba(255,255,255,0.1); border: 3px solid white; border-radius: 50%; pointer-events: auto; display: flex; align-items: center; justify-content: center; color: white; font-size: 32px; -webkit-user-select: none; }
    </style>
</head>
<body>
    <div id="status-ui"></div>
    <div id="seed-container">SEED: <input type="text" id="seed-display-val" readonly></div>
    <div id="side-panel"><h3>COMMAND INPUT</h3><input type="text" id="side-input" placeholder="Type here..."></div>
    <div id="device-menu"><h1>SELECT DEVICE</h1><button class="btn" onclick="selectDevice('pc')">PC</button><button class="btn" onclick="selectDevice('mobile')">MOBILE</button></div>
    <div id="menu" style="display:none"><canvas id="menu-canvas"></canvas><h1>VOID ECHO</h1><input type="text" id="seed-input" placeholder="Seed..." maxlength="15"><button id="start-btn" class="btn">START</button></div>
    <div id="mobile-controls"><div style="display:flex; gap: 25px;"><div class="joy-btn" id="m-left">‚Üê</div><div class="joy-btn" id="m-right">‚Üí</div></div><div class="joy-btn" id="m-jump">‚ñ≤</div></div>
    <div id="hud"><div id="hearts"></div><div id="hotbar"><div class="slot active unlocked">üü´</div><div class="slot unlocked">üî•</div><div class="slot unlocked">üíß</div><div class="slot"></div><div class="slot"></div><div class="slot unlocked" id="slot5" style="display:none">üåà</div></div></div>
    <canvas id="game"></canvas>

<script>
    function lerp(a, b, t) { return a + (b - a) * t; }

function getNoise(x, y, s) {
    let n = Math.sin(x * 0.12 + y * 0.13 + s) * 43758.5453;
    return n - Math.floor(n);
}

function smoothNoise(x, y, s) {
    let xi = Math.floor(x), yi = Math.floor(y);
    let xf = x - xi, yf = y - yi;
    let u = xf * xf * (3 - 2 * xf);
    let v = yf * yf * (3 - 2 * yf);
    return lerp(lerp(getNoise(xi, yi, s), getNoise(xi+1, yi, s), u),
                lerp(getNoise(xi, yi+1, s), getNoise(xi+1, yi+1, s), u), v);
}

const canvas = document.getElementById('game'), ctx = canvas.getContext('2d'), menuCanvas = document.getElementById('menu-canvas'), mCtx = menuCanvas.getContext('2d');
const ITEMS = ['dirt', 'lava', 'water', null, null, 'rainbow'], LIQUIDS = ['water', 'lava', 'rainbow'], TILE = 32, GRAVITY = 0.4, JUMP = -8.5, SPEED = 3.5;
let isGameStarted = false, rainbowHue = 0, cameraZoom = 1.0, isNoclip = false, isGodMode = false, isSoundMuted = false, isAdmin = false, currentSeed = "0", isMobile = false;
let player = { x: 0, y: 0, vx: 0, vy: 0, w: 22, h: 36, grounded: false, inWater: false, walkTimer: 0, dir: 1, hurtTint: 0, hp: 10, maxHp: 10, lastHit: 0, selectedSlot: 0 };
let world = {}, particles = [], clones = [], liquidUpdateFrame = 0;
let monster = { x: 0, y: 0, active: false, timer: 0, nextSpawn: Date.now() + 300000 };
const keys = {};

function selectDevice(t) { isMobile = (t === 'mobile'); document.getElementById('device-menu').style.display = 'none'; document.getElementById('menu').style.display = 'flex'; if (isMobile) document.getElementById('mobile-controls').style.display = 'flex'; initMenu(); }
function spawnParticles(x, y, color) { for(let i=0; i<10; i++) particles.push({ x: x+Math.random()*TILE, y: y+Math.random()*TILE, vx: (Math.random()-0.5)*4, vy: Math.random()*2, life: 300, color: color }); }
function spawnClone() { clones.push({ x: player.x, y: player.y, vx: (Math.random()-0.5)*5, vy: JUMP, w: 22, h: 36, dir: Math.random()>0.5?1:-1, walkTimer: 0, grounded: false }); }

function updateLiquids() {
    let tiles = Object.keys(world);
    for (let key of tiles) {
        let b = world[key];
        if (LIQUIDS.includes(b.type)) {
            let [x, y] = key.split(',').map(Number);
            if (y > 174) continue;
            if (b.type === 'rainbow') {
                [`${x},${y+1}`, `${x-1},${y}`, `${x+1},${y}`].forEach(n => { if(!world[n]) world[n]={type:'rainbow', dist:0}});
                continue;
            }
            let down = `${x},${y+1}`;
            if (!world[down]) { world[down] = { type: b.type, dist: 0 }; continue; }
            let max = b.type === 'water' ? 7 : 3;
            if (b.dist < max) {
                if (!world[`${x-1},${y}`]) world[`${x-1},${y}`] = { type: b.type, dist: b.dist + 1 };
                if (!world[`${x+1},${y}`]) world[`${x+1},${y}`] = { type: b.type, dist: b.dist + 1 };
            }
        }
    }
}

// –£–ª—É—á—à–µ–Ω–Ω–æ–µ –ø–µ—Ä–µ–º–µ—à–∏–≤–∞–Ω–∏–µ —Å–∏–¥–∞
function cyrb128(str) {
    let h1 = 1779033703, h2 = 1911520191, h3 = 2854904213, h4 = 3387418403;
    for (let i = 0, k; i < str.length; i++) {
        k = str.charCodeAt(i);
        h1 = h2 ^ Math.imul(h1 ^ k, 597399067);
        h2 = h3 ^ Math.imul(h2 ^ k, 2869860233);
        h3 = h4 ^ Math.imul(h3 ^ k, 951274213);
        h4 = h1 ^ Math.imul(h4 ^ k, 2716044179);
    }
    h1 = Math.imul(h3 ^ (h1 >>> 18), 597399067);
    h2 = Math.imul(h4 ^ (h2 >>> 22), 2869860233);
    h3 = Math.imul(h1 ^ (h3 >>> 17), 951274213);
    h4 = Math.imul(h2 ^ (h4 >>> 19), 2716044179);
    return [(h1^h2^h3^h4)>>>0, (h2^h1)>>>0, (h3^h1)>>>0, (h4^h1)>>>0];
}

function sfc32(a, b, c, d) {
    return function() {
        a >>>= 0; b >>>= 0; c >>>= 0; d >>>= 0; 
        var t = (a + b | 0) + d | 0;
        d = d + 1 | 0;
        a = b ^ b >>> 9;
        b = c + (c << 3) | 0;
        c = (c << 21 | c >>> 11);
        c = c + t | 0;
        return (t >>> 0) / 4294967296;
    }
}

function drawChar(x, y, dir, wt, tint, isFake = false) {
    ctx.save(); ctx.translate(x + 11, y + 18);
    if (!isFake && isAdmin) {
        ctx.save(); ctx.scale(1/cameraZoom, 1/cameraZoom); ctx.font = "bold 14px 'Courier New'"; ctx.textAlign = "center";
        ctx.shadowBlur = 10; ctx.shadowColor = "#0f0"; ctx.fillStyle = "#0f0"; ctx.fillText("[Admin]", 0, -36 * cameraZoom - 15); ctx.restore();
        ctx.fillStyle = "#FF8C00"; ctx.beginPath(); ctx.moveTo(-6, -18); ctx.lineTo(-10, -30); ctx.lineTo(-2, -18); ctx.moveTo(6, -18); ctx.lineTo(10, -30); ctx.lineTo(2, -18); ctx.fill();
    }
    if (dir === -1) ctx.scale(-1, 1);
    if (!isFake && isNoclip) ctx.globalAlpha = 0.75;
    let pCol = tint > 0 ? "red" : (isFake ? "rgba(255,0,0,0.6)" : getDepthColor(y + 18));
    ctx.strokeStyle = pCol; ctx.fillStyle = "black"; ctx.lineWidth = 2;
    ctx.fillRect(-11, -18, 22, 28); ctx.strokeRect(-11, -18, 22, 28);
    let lm = Math.sin(wt) * 6; ctx.strokeRect(-8, 10, 4, 8 + lm); ctx.strokeRect(4, 10, 4, 8 - lm);
    ctx.fillStyle = pCol; ctx.fillRect(2, -8, 6, 2); ctx.fillRect(-6, -8, 6, 2); ctx.restore();
}

// –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Ü–≤–µ—Ç –¥–ª—è –±–ª–æ–∫–∞ –Ω–∞ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω–æ–π –≤—ã—Å–æ—Ç–µ Y
// –ì—Ä–∞–¥–∏–µ–Ω—Ç: –∫—Ä–∞—Å–Ω—ã–π (–Ω–∏–∑) -> –±–µ–ª—ã–π (–≤–µ—Ä—Ö)
function getDepthColor(y) {
    // –ë–ª–æ–∫–∏ –≤—ã—à–µ –≤—ã—Å–æ—Ç—ã 20 - –±–µ–ª—ã–µ
    if (y < 20) return "white";
    
    // –ù–æ—Ä–º–∞–ª–∏–∑—É–µ–º –≤—ã—Å–æ—Ç—É –æ—Ç 0 –¥–æ 1
    // 0 = —Å–∞–º–∞—è –≤—ã—Å–æ–∫–∞—è —Ç–æ—á–∫–∞ –≥—Ä–∞–¥–∏–µ–Ω—Ç–∞ (20 –±–ª–æ–∫–æ–≤ –≤–Ω–∏–∑ –æ—Ç —Å–∞–º–æ–π –Ω–∏–∑–∫–æ–π –ø–æ–≤–µ—Ä—Ö–Ω–æ—Å—Ç–∏)
    // 1 = —Å–∞–º–∞—è –Ω–∏–∑–∫–∞—è —Ç–æ—á–∫–∞ –≥—Ä–∞–¥–∏–µ–Ω—Ç–∞ (—Å–∞–º–∞—è –Ω–∏–∑–∫–∞—è –ø–æ–≤–µ—Ä—Ö–Ω–æ—Å—Ç—å)
    let normalizedY = Math.max(0, Math.min(20, y)) / 20;
    
    // –ì—Ä–∞–¥–∏–µ–Ω—Ç –æ—Ç –∫—Ä–∞—Å–Ω–æ–≥–æ –∫ –±–µ–ª–æ–º—É
    // –ö—Ä–∞—Å–Ω—ã–π: rgb(255, 0, 0)
    // –ë–µ–ª—ã–π: rgb(255, 255, 255)
    let red = 255;
    let green = Math.floor(255 * (1 - normalizedY));
    let blue = Math.floor(255 * (1 - normalizedY));
    
    return `rgb(${red}, ${green}, ${blue})`;
}
function checkColl(obj, isX) {
    if (obj === player && isNoclip) return;
    let x1 = Math.floor(obj.x/TILE), x2 = Math.floor((obj.x+obj.w)/TILE), y1 = Math.floor(obj.y/TILE), y2 = Math.floor((obj.y+obj.h)/TILE);
    for (let tx = x1; tx <= x2; tx++) for (let ty = y1; ty <= y2; ty++) {
        let b = world[`${tx},${ty}`];
        if (!b || LIQUIDS.includes(b.type)) {
            if (b && obj === player) { 
                player.inWater = true; 
                if (b.type === 'lava' && !isGodMode && Date.now() - player.lastHit > 500) { player.hp--; player.hurtTint = 10; player.lastHit = Date.now(); updateUI(); }
            }
            continue;
        }
        if (isX) { if (obj.vx > 0) obj.x = tx * TILE - obj.w - 0.01; else if (obj.vx < 0) obj.x = (tx + 1) * TILE + 0.01; if (obj !== player) obj.dir *= -1; }
        else { if (obj.vy > 0) { obj.y = ty * TILE - obj.h - 0.01; obj.vy = 0; obj.grounded = true; } else if (obj.vy < 0) { obj.y = (ty + 1) * TILE + 0.01; obj.vy = 0; } }
    }
}

// --- –ì–ï–ù–ï–†–ê–¢–û–† –ë–ï–°–ö–û–ù–ï–ß–ù–û–ì–û –ú–ò–†–ê ---
// ================ –ù–û–í–´–ï –§–£–ù–ö–¶–ò–ò –ì–ï–ù–ï–†–ê–¶–ò–ò ================

// 1. –ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç –≤—ã—Å–æ—Ç—É –ø–æ–≤–µ—Ä—Ö–Ω–æ—Å—Ç–∏ –¥–ª—è –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã X
// ================ –ù–û–í–´–ï –§–£–ù–ö–¶–ò–ò –ì–ï–ù–ï–†–ê–¶–ò–ò ================

// 1. –ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç –≤—ã—Å–æ—Ç—É –ø–æ–≤–µ—Ä—Ö–Ω–æ—Å—Ç–∏ –¥–ª—è –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã X
// ================ –£–õ–£–ß–®–ï–ù–ù–ê–Ø –ì–ï–ù–ï–†–ê–¶–ò–Ø –° –ì–û–†–ê–ú–ò ================

// 1. –ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç –≤—ã—Å–æ—Ç—É –ø–æ–≤–µ—Ä—Ö–Ω–æ—Å—Ç–∏ —Å –≥–æ—Ä–∞–º–∏
function generateSurfaceHeight(x) {
    const [s1, s2, s3] = cyrb128(currentSeed);
    
    // –ú–∞—Å—à—Ç–∞–±—ã —à—É–º–æ–≤
    const baseScale = 0.02;     // –û—á–µ–Ω—å –∫—Ä—É–ø–Ω—ã–µ —Ñ–æ—Ä–º—ã
    const mountainScale = 0.008; // –û–≥—Ä–æ–º–Ω—ã–µ –≥–æ—Ä–Ω—ã–µ —Ö—Ä–µ–±—Ç—ã
    const hillScale = 0.06;     // –°—Ä–µ–¥–Ω–∏–µ —Ö–æ–ª–º—ã
    const detailScale = 0.15;   // –ú–µ–ª–∫–∏–µ –¥–µ—Ç–∞–ª–∏
    
    // –ê–º–ø–ª–∏—Ç—É–¥—ã
    const baseAmplitude = 35;    // –ë–∞–∑–æ–≤—ã–π —Ä–µ–ª—å–µ—Ñ
    const mountainAmplitude = 80; // –í—ã—Å–æ–∫–∏–µ –≥–æ—Ä—ã
    const hillAmplitude = 25;    // –•–æ–ª–º—ã
    const detailAmplitude = 8;   // –î–µ—Ç–∞–ª–∏–∑–∞—Ü–∏—è
    
    const baseHeight = 80;
    
    // 1. –û—á–µ–Ω—å –∫—Ä—É–ø–Ω—ã–µ —Ñ–æ—Ä–º—ã (–∫–æ–Ω—Ç–∏–Ω–µ–Ω—Ç—ã)
    let baseNoise = smoothNoise(x * baseScale, 0, s1) * baseAmplitude;
    
    // 2. –ì–æ—Ä–Ω—ã–µ —Ö—Ä–µ–±—Ç—ã (—Ä–µ–¥–∫–∏–µ, –Ω–æ –≤—ã—Å–æ–∫–∏–µ)
    let mountainMask = smoothNoise(x * 0.005, 500, s2); // –û–ø—Ä–µ–¥–µ–ª—è–µ–º –≥–¥–µ –±—É–¥—É—Ç –≥–æ—Ä—ã
    let mountainNoise = smoothNoise(x * mountainScale, 1000, s1);
    let mountains = 0;
    if (mountainMask > 0.5) { // –ì–æ—Ä—ã —Ç–æ–ª—å–∫–æ –≤ –Ω–µ–∫–æ—Ç–æ—Ä—ã—Ö –º–µ—Å—Ç–∞—Ö
        mountains = mountainNoise * mountainAmplitude * (mountainMask - 0.5) * 2;
    }
    
    // 3. –°—Ä–µ–¥–Ω–∏–µ —Ö–æ–ª–º—ã
    let hillNoise = smoothNoise(x * hillScale, 2000, s2) * hillAmplitude;
    
    // 4. –ú–µ–ª–∫–∏–µ –¥–µ—Ç–∞–ª–∏
    let detailNoise = smoothNoise(x * detailScale, 3000, s3) * detailAmplitude;
    
    // –ö–æ–º–±–∏–Ω–∏—Ä—É–µ–º –≤—Å–µ —Å–ª–æ–∏
    let height = baseHeight + baseNoise + mountains + hillNoise + detailNoise;
    
    // –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –≤—ã—Å–æ—Ç—É (–≥–æ—Ä—ã –º–æ–≥—É—Ç –±—ã—Ç—å –¥–æ 180, —Ä–∞–≤–Ω–∏–Ω—ã –æ—Ç 60)
    return Math.floor(Math.max(60, Math.min(180, height)));
}

// 2. –ù–∞—Ö–æ–¥–∏—Ç –∞–±—Å–æ–ª—é—Ç–Ω—É—é –º–∏–Ω–∏–º–∞–ª—å–Ω—É—é –≤—ã—Å–æ—Ç—É –ø–æ–≤–µ—Ä—Ö–Ω–æ—Å—Ç–∏
function findAbsoluteMinSurfaceHeight() {
    let minHeight = 180; // –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–æ –≤–æ–∑–º–æ–∂–Ω–∞—è –≤—ã—Å–æ—Ç–∞
    const [s1] = cyrb128(currentSeed);
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º 1000 –±–ª–æ–∫–æ–≤ –≤ –∫–∞–∂–¥—É—é —Å—Ç–æ—Ä–æ–Ω—É –¥–ª—è –Ω–∞–¥–µ–∂–Ω–æ—Å—Ç–∏
    for (let x = -500; x <= 500; x++) {
        let height = generateSurfaceHeight(x);
        if (height < minHeight) {
            minHeight = height;
        }
    }
    
    return minHeight;
}

// 3. –ü–ª–∞–≤–Ω—ã–π –≥—Ä–∞–¥–∏–µ–Ω—Ç–Ω—ã–π —Ü–≤–µ—Ç
function getSmoothGradientColor(gradientHeight) {
    // gradientHeight: 0-20 (0 = –≤–µ—Ä—Ö –≥—Ä–∞–¥–∏–µ–Ω—Ç–∞, 20 = –Ω–∏–∑ –≥—Ä–∞–¥–∏–µ–Ω—Ç–∞)
    
    if (gradientHeight <= 0) return "white";
    if (gradientHeight >= 20) return "rgb(255, 0, 0)";
    
    // –ò—Å–ø–æ–ª—å–∑—É–µ–º –∫—É–±–∏—á–µ—Å–∫—É—é –∏–Ω—Ç–µ—Ä–ø–æ–ª—è—Ü–∏—é –¥–ª—è –ø–ª–∞–≤–Ω–æ—Å—Ç–∏
    let t = gradientHeight / 20;
    
    // –ü–ª–∞–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è easing
    let smoothT = t * t * (3 - 2 * t); // –ö—É–±–∏—á–µ—Å–∫–∞—è –∏–Ω—Ç–µ—Ä–ø–æ–ª—è—Ü–∏—è
    
    // –¶–≤–µ—Ç–∞ –¥–ª—è –≥—Ä–∞–¥–∏–µ–Ω—Ç–∞
    let startColor = { r: 255, g: 255, b: 255 }; // –ë–µ–ª—ã–π
    let endColor = { r: 255, g: 0, b: 0 };      // –ö—Ä–∞—Å–Ω—ã–π
    
    // –ü–ª–∞–≤–Ω—ã–π –ø–µ—Ä–µ—Ö–æ–¥
    let r = Math.floor(startColor.r + (endColor.r - startColor.r) * smoothT);
    let g = Math.floor(startColor.g + (endColor.g - startColor.g) * smoothT);
    let b = Math.floor(startColor.b + (endColor.b - startColor.b) * smoothT);
    
    return `rgb(${r}, ${g}, ${b})`;
}

// 4. –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, –µ—Å—Ç—å –ª–∏ –ø–µ—â–µ—Ä–∞ –≤ —ç—Ç–æ–π –ø–æ–∑–∏—Ü–∏–∏
function isCave(x, y, surfaceHeight) {
    const [s1, s2] = cyrb128(currentSeed);
    
    // –¢–æ–ª—å–∫–æ –ø–æ–¥ –∑–µ–º–ª–µ–π
    if (y >= surfaceHeight - 5) return false;
    
    // –ì–ª—É–±–∏–Ω–∞ –æ—Ç –ø–æ–≤–µ—Ä—Ö–Ω–æ—Å—Ç–∏
    let depth = surfaceHeight - y;
    
    // –í–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å –ø–µ—â–µ—Ä —É–≤–µ–ª–∏—á–∏–≤–∞–µ—Ç—Å—è —Å –≥–ª—É–±–∏–Ω–æ–π
    let caveChance = 0.3 + (depth / 100) * 0.4;
    
    // –ë–æ–ª—å—à–∏–µ –ø–µ—â–µ—Ä—ã –≥–ª—É–±–æ–∫–æ
    let bigCaveNoise = smoothNoise(x * 0.12, y * 0.12, s1);
    if (depth > 40 && bigCaveNoise > (1 - caveChance)) return true;
    
    // –ú–µ–ª–∫–∏–µ –ø–µ—â–µ—Ä—ã
    let smallCaveNoise = smoothNoise(x * 0.25, y * 0.25, s2);
    if (smallCaveNoise > 0.78) return true;
    
    // –í–µ—Ä—Ç–∏–∫–∞–ª—å–Ω—ã–µ –ø–µ—â–µ—Ä—ã (—à–∞—Ö—Ç—ã)
    let verticalCave = smoothNoise(x * 0.4, 0, s1);
    if (verticalCave > 0.9 && Math.abs(x % 20) < 2) return true;
    
    return false;
}

// 5. –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –ª–∏ –ø–æ–∑–∏—Ü–∏—è –Ω–∞ —Å–∫–ª–æ–Ω–µ –≥–æ—Ä—ã
function isMountainSlope(x, y, surfaceHeight) {
    const [s1] = cyrb128(currentSeed);
    
    // –¢–æ–ª—å–∫–æ –Ω–∞ –ø–æ–≤–µ—Ä—Ö–Ω–æ—Å—Ç–∏ –∏–ª–∏ –æ–∫–æ–ª–æ –Ω–µ–µ
    if (y < surfaceHeight - 10 || y > surfaceHeight) return false;
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫—Ä—É—Ç–∏–∑–Ω—É —Å–∫–ª–æ–Ω–∞
    let heightHere = generateSurfaceHeight(x);
    let heightLeft = generateSurfaceHeight(x - 1);
    let heightRight = generateSurfaceHeight(x + 1);
    
    // –ö—Ä—É—Ç–æ–π —Å–∫–ª–æ–Ω –µ—Å–ª–∏ —Ä–∞–∑–Ω–∏—Ü–∞ –±–æ–ª—å—à–µ 3 –±–ª–æ–∫–æ–≤
    let steepLeft = Math.abs(heightHere - heightLeft) > 3;
    let steepRight = Math.abs(heightHere - heightRight) > 3;
    
    return steepLeft || steepRight;
}

// 6. –ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç –æ–¥–∏–Ω –±–ª–æ–∫ –≤ –ø–æ–∑–∏—Ü–∏–∏ (x, y)
function generateBlockAt(x, y) {
    // 1. –ë–ï–î–†–û–ö (–¥–Ω–æ –º–∏—Ä–∞)
    if (y >= 175) {
        return { type: 'bedrock' };
    }
    
    // 2. –û–ø—Ä–µ–¥–µ–ª—è–µ–º –≤—ã—Å–æ—Ç—É –ø–æ–≤–µ—Ä—Ö–Ω–æ—Å—Ç–∏ –¥–ª—è —ç—Ç–æ–π –∫–æ–ª–æ–Ω–∫–∏
    let surfaceHeight = generateSurfaceHeight(x);
    
    // 3. –ê–î (–≥–ª—É–±–∏–Ω–∞ > 130 –±–ª–æ–∫–æ–≤)
    if (y > 130) {
        // –ë–æ–ª—å—à–µ –ø–µ—â–µ—Ä –≤ –∞–¥—É
        if (Math.random() < 0.5) return null;
        
        let hellDepth = y - 130;
        let redIntensity = Math.min(255, 50 + hellDepth * 5);
        
        // –î–æ–±–∞–≤–ª—è–µ–º –Ω–µ–º–Ω–æ–≥–æ –≤–∞—Ä–∏–∞—Ç–∏–≤–Ω–æ—Å—Ç–∏
        let variation = Math.sin(x * 0.1 + y * 0.05) * 20;
        redIntensity = Math.max(50, Math.min(255, redIntensity + variation));
        
        return {
            type: 'hellstone',
            color: `rgb(${redIntensity}, 0, 0)`
        };
    }
    
    // 4. –ï—Å–ª–∏ –í–´–®–ï –ø–æ–≤–µ—Ä—Ö–Ω–æ—Å—Ç–∏ - –í–û–ó–î–£–• (–∫–æ–≥–¥–∞ –∏–≥—Ä–æ–∫ –≤—ã—Å–æ–∫–æ –≤ –≥–æ—Ä–∞—Ö)
    if (y > surfaceHeight) {
        // –°–Ω–µ–≥ –Ω–∞ –≤–µ—Ä—à–∏–Ω–∞—Ö –≤—ã—Å–æ–∫–∏—Ö –≥–æ—Ä
        if (surfaceHeight > 140 && y === surfaceHeight + 1) {
            if (Math.random() < 0.7) return { type: 'snow' };
        }
        return null; // –í–æ–∑–¥—É—Ö
    }
    
    // 5. –ï—Å–ª–∏ –†–û–í–ù–û –Ω–∞ –ø–æ–≤–µ—Ä—Ö–Ω–æ—Å—Ç–∏
    if (y === surfaceHeight) {
        // –°–Ω–µ–≥ –Ω–∞ –≤—ã—Å–æ–∫–∏—Ö –≥–æ—Ä–∞—Ö
        if (surfaceHeight > 140) {
            return { type: 'snow' };
        }
        // –ö–∞–º–µ–Ω—å –Ω–∞ –∫—Ä—É—Ç—ã—Ö —Å–∫–ª–æ–Ω–∞—Ö
        else if (isMountainSlope(x, y, surfaceHeight)) {
            return { type: 'stone' };
        }
        // –û–±—ã—á–Ω–∞—è —Ç—Ä–∞–≤–∞
        else {
            return { type: 'grass' };
        }
    }
    
    // 6. –ï—Å–ª–∏ —Å—Ä–∞–∑—É –ø–æ–¥ –ø–æ–≤–µ—Ä—Ö–Ω–æ—Å—Ç—å—é
    if (y < surfaceHeight && y > surfaceHeight - 5) {
        // –ù–∞ –≥–æ—Ä–∞—Ö —Å—Ä–∞–∑—É –∫–∞–º–µ–Ω—å –ø–æ–¥ —Å–Ω–µ–≥–æ–º
        if (surfaceHeight > 140 && y === surfaceHeight - 1) {
            return { type: 'stone' };
        }
        return { type: 'dirt' };
    }
    
    // 7. –ù–∞—Ö–æ–¥–∏–º –∞–±—Å–æ–ª—é—Ç–Ω—É—é –º–∏–Ω–∏–º–∞–ª—å–Ω—É—é –≤—ã—Å–æ—Ç—É –¥–ª—è –≥—Ä–∞–¥–∏–µ–Ω—Ç–∞
    // (–≤—ã—á–∏—Å–ª—è–µ–º –æ–¥–∏–Ω —Ä–∞–∑ –∏ –∫—ç—à–∏—Ä—É–µ–º)
    if (!window.absoluteMinSurfaceHeight) {
        window.absoluteMinSurfaceHeight = findAbsoluteMinSurfaceHeight();
    }
    let absoluteMin = window.absoluteMinSurfaceHeight;
    let gradientStartY = absoluteMin - 20; // –ù–∞—á–∏–Ω–∞–µ–º –≥—Ä–∞–¥–∏–µ–Ω—Ç –∑–∞ 20 –±–ª–æ–∫–æ–≤ –î–û —Å–∞–º–æ–π –Ω–∏–∑–∫–æ–π —Ç–æ—á–∫–∏
    
    // 8. –ì–†–ê–î–ò–ï–ù–¢–ù–´–ô –°–õ–û–ô (20 –±–ª–æ–∫–æ–≤ –≤–Ω–∏–∑ –æ—Ç —Å–∞–º–æ–π –Ω–∏–∑–∫–æ–π —Ç–æ—á–∫–∏ –ø–æ–≤–µ—Ä—Ö–Ω–æ—Å—Ç–∏)
    if (y >= gradientStartY && y < surfaceHeight) {
        // –í—ã—á–∏—Å–ª—è–µ–º –≤—ã—Å–æ—Ç—É –≤ –≥—Ä–∞–¥–∏–µ–Ω—Ç–µ (0-20)
        // 0 = –≤–µ—Ä—Ö –≥—Ä–∞–¥–∏–µ–Ω—Ç–∞ (—Å–∞–º–∞—è –Ω–∏–∑–∫–∞—è –ø–æ–≤–µ—Ä—Ö–Ω–æ—Å—Ç—å - 20)
        // 20 = –Ω–∏–∑ –≥—Ä–∞–¥–∏–µ–Ω—Ç–∞ (—Å–∞–º–∞—è –Ω–∏–∑–∫–∞—è –ø–æ–≤–µ—Ä—Ö–Ω–æ—Å—Ç—å)
        let gradientHeight = y - gradientStartY;
        
        // –¢–æ–ª—å–∫–æ –¥–ª—è –∫–∞–º–Ω—è –≤ –≥—Ä–∞–¥–∏–µ–Ω—Ç–Ω–æ–º —Å–ª–æ–µ (–Ω–∏–∂–µ —Å–ª–æ—è –∑–µ–º–ª–∏)
        if (y < surfaceHeight - 5) {
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø–µ—â–µ—Ä—ã –≤ –≥—Ä–∞–¥–∏–µ–Ω—Ç–Ω–æ–º —Å–ª–æ–µ
            if (isCave(x, y, surfaceHeight)) {
                return null;
            }
            
            return {
                type: 'stone',
                color: getSmoothGradientColor(gradientHeight)
            };
        }
    }
    
    // 9. –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø–µ—â–µ—Ä—ã (–¥–ª—è –æ–±—ã—á–Ω–æ–≥–æ –∫–∞–º–Ω—è)
    if (y < surfaceHeight - 5) {
        if (isCave(x, y, surfaceHeight)) {
            return null; // –í–æ–∑–¥—É—Ö –≤ –ø–µ—â–µ—Ä–µ
        }
    }
    
    // 10. –û–±—ã—á–Ω—ã–π –∫–∞–º–µ–Ω—å (–≤—Å–µ —á—Ç–æ –≥–ª—É–±–∂–µ 5 –±–ª–æ–∫–æ–≤ –æ—Ç –ø–æ–≤–µ—Ä—Ö–Ω–æ—Å—Ç–∏)
    if (y < surfaceHeight - 5) {
        return { type: 'stone' };
    }
    
    // 11. –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é - –≤–æ–∑–¥—É—Ö
    return null;
}

// 7. –û—Å–Ω–æ–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏
function generateRegion(startX, endX) {
    const storageKey = 'void_echo_mountains_' + currentSeed;
    const mods = JSON.parse(localStorage.getItem(storageKey) || '{}');
    
    // –ö—ç—à–∏—Ä—É–µ–º –∞–±—Å–æ–ª—é—Ç–Ω—É—é –º–∏–Ω–∏–º–∞–ª—å–Ω—É—é –≤—ã—Å–æ—Ç—É
    if (!window.absoluteMinSurfaceHeight) {
        window.absoluteMinSurfaceHeight = findAbsoluteMinSurfaceHeight();
    }
    
    for (let x = startX; x < endX; x++) {
        // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –æ—Ç –Ω–µ–±–∞ (–≤—ã—Å–æ—Ç–∞ 0) –¥–æ –¥–Ω–∞ –º–∏—Ä–∞
        for (let y = 0; y < 180; y++) {
            let key = `${x},${y}`;
            
            // –ü—Ä–æ–ø—É—Å–∫–∞–µ–º —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–µ –±–ª–æ–∫–∏
            if (world[key]) continue;
            
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º –º–æ–¥–∏—Ñ–∏–∫–∞—Ü–∏–∏ –∏–≥—Ä–æ–∫–∞
            if (mods[key]) {
                if (mods[key] === "deleted") continue;
                world[key] = { type: mods[key], modified: true };
                continue;
            }
            
            // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –Ω–æ–≤—ã–π –±–ª–æ–∫
            let block = generateBlockAt(x, y);
            if (block) {
                world[key] = block;
            }
        }
    }
}
// ================ –û–ë–ù–û–í–õ–ï–ù–ù–ê–Ø –§–£–ù–ö–¶–ò–Ø –û–¢–†–ò–°–û–í–ö–ò ================

// –í —Ñ—É–Ω–∫—Ü–∏–∏ gameLoop, –≤ —á–∞—Å—Ç–∏ –æ—Ç—Ä–∏—Å–æ–≤–∫–∏ –±–ª–æ–∫–æ–≤, –∑–∞–º–µ–Ω–∏—Ç–µ –Ω–∞:
function drawBlockWithStyle(wx, wy, b, yOff = 0, alpha = 1) {
    ctx.save();
    ctx.globalAlpha = alpha;
    
    if (b.type === 'lava') { 
        ctx.fillStyle = "#FF4500"; 
        ctx.fillRect(wx, wy + yOff + 4, TILE, TILE - 4); 
    } else if (b.type === 'water') { 
        ctx.fillStyle = "#00BFFF"; 
        ctx.fillRect(wx, wy + yOff + 4, TILE, TILE - 4); 
    } else if (b.type === 'rainbow') { 
        ctx.fillStyle = `hsl(${rainbowHue}, 80%, 50%)`; 
        ctx.fillRect(wx, wy + yOff, TILE, TILE); 
    } else if (b.color) {
        // –î–ª—è –≥—Ä–∞–¥–∏–µ–Ω—Ç–Ω—ã—Ö –∏ –∞–¥—Å–∫–∏—Ö –±–ª–æ–∫–æ–≤
        ctx.fillStyle = b.color;
        ctx.fillRect(wx, wy + yOff, TILE, TILE);
        ctx.strokeStyle = "#333";
        ctx.lineWidth = 1;
        ctx.strokeRect(wx, wy + yOff, TILE, TILE);
    } else {
        // –î–ª—è –æ–±—ã—á–Ω—ã—Ö –±–ª–æ–∫–æ–≤
        let strokeColor = "#666";
        if (b.type === 'bedrock') strokeColor = "#444";
        if (b.type === 'grass') strokeColor = "#0a0";
        if (b.type === 'dirt') strokeColor = "#963";
        
        ctx.strokeStyle = strokeColor;
        ctx.lineWidth = b.type === 'bedrock' ? 4 : 2;
        ctx.strokeRect(wx + 2, wy + yOff + 2, TILE - 4, TILE - 4);
    }
    
    ctx.restore();
}

// –ó–∞—Ç–µ–º –≤ —Ü–∏–∫–ª–µ –æ—Ç—Ä–∏—Å–æ–≤–∫–∏ –≤ gameLoop –≤—ã–∑–æ–≤–∏—Ç–µ:
// –ó–∞–º–µ–Ω–∏—Ç–µ –±–ª–æ–∫ –∫–æ–¥–∞ –æ—Ç—Ä–∏—Å–æ–≤–∫–∏ –Ω–∞:
/*
for (let x = Math.floor(player.x / TILE - vw); x < Math.ceil(player.x / TILE + vw); x++) {
    for (let y = Math.floor(player.y / TILE - vh); y < Math.ceil(player.y / TILE + vh); y++) {
        const b = world[`${x},${y}`]; 
        if (!b) continue;

        const wx = x * TILE;
        const wy = y * TILE;

        // ... —Ä–∞—Å—á–µ—Ç yOff –∏ alpha ...

        drawBlockWithStyle(wx, wy, b, yOff, alpha);
    }
}
*/
function gameLoop() {
    if (!isGameStarted) return;

    // 1. –°–ò–°–¢–ï–ú–ù–´–ï –û–ë–ù–û–í–õ–ï–ù–ò–Ø
    rainbowHue = (rainbowHue + 2) % 360;
    if (isGodMode) updateUI();
    
    // 2. –ë–ï–°–ö–û–ù–ï–ß–ù–ê–Ø –ì–ï–ù–ï–†–ê–¶–ò–Ø (GitHub Optimized 2025)
    // –ü–æ–¥–≥—Ä—É–∂–∞–µ–º –º–∏—Ä –Ω–∞ 60 –±–ª–æ–∫–æ–≤ –≤–æ–∫—Ä—É–≥ –∏–≥—Ä–æ–∫–∞ –≤ —Ä–µ–∞–ª—å–Ω–æ–º –≤—Ä–µ–º–µ–Ω–∏
    let currentTileX = Math.floor(player.x / TILE);
    generateRegion(currentTileX - 60, currentTileX + 60);

    // 3. –§–ò–ó–ò–ö–ê –ò –£–ü–†–ê–í–õ–ï–ù–ò–ï –ò–ì–†–û–ö–û–ú
    let mx = 0; 
    if (keys['KeyA'] || (isMobile && keys['m-left'])) mx = -SPEED; 
    if (keys['KeyD'] || (isMobile && keys['m-right'])) mx = SPEED;
    
    if (isNoclip) {
        player.vx = player.vy = 0; 
        if (mx < 0) { player.x -= SPEED * 2; player.dir = -1; } 
        if (mx > 0) { player.x += SPEED * 2; player.dir = 1; }
        if (keys['Space'] || (isMobile && keys['m-jump'])) player.y -= SPEED * 2; 
        if (keys['ShiftLeft']) player.y += SPEED * 2;
    } else {
        player.vx = mx; 
        if (mx !== 0) { player.dir = mx > 0 ? 1 : -1; player.walkTimer += 0.15; }
        player.x += player.vx; 
        checkColl(player, true);
        
        if (player.inWater) {
            player.vy = (keys['Space'] || (isMobile && keys['m-jump'])) ? -4 : Math.min(player.vy + 0.1, 1.5);
        } else { 
            player.vy += GRAVITY; 
            if ((keys['Space'] || (isMobile && keys['m-jump'])) && player.grounded) { 
                player.vy = JUMP; 
                player.grounded = false; 
            } 
        }
        player.y += player.vy; 
        player.grounded = false; 
        player.inWater = false; 
        checkColl(player, false);
    }

    // 4. –°–£–©–ù–û–°–¢–ò –ò –ñ–ò–î–ö–û–°–¢–ò
    clones.forEach(c => { 
        c.vx = c.dir * SPEED; c.x += c.vx; checkColl(c, true); 
        c.vy += GRAVITY; if (c.grounded && Math.random() < 0.02) c.vy = JUMP; 
        c.y += c.vy; c.grounded = false; checkColl(c, false); c.walkTimer += 0.15; 
    });
    if (++liquidUpdateFrame % 10 === 0) updateLiquids();

    // 5. –ù–ê–°–¢–†–û–ô–ö–ê –•–û–õ–°–¢–ê –ò –ê–¢–ú–û–°–§–ï–†–´ (–ê–î)
    canvas.width = window.innerWidth; 
    canvas.height = window.innerHeight;
    
    let depth = player.y / TILE;
    if (depth > 130) {
        // –≠—Ñ—Ñ–µ–∫—Ç —Ä–∞—Å–∫–∞–ª–µ–Ω–Ω–æ–≥–æ –≤–æ–∑–¥—É—Ö–∞ –≤ –∞–¥—É
        let redTone = Math.min(45, (depth - 130) * 2.5);
        ctx.fillStyle = `rgb(${redTone}, 0, 0)`;
    } else {
        ctx.fillStyle = "black";
    }
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // 6. –ö–ê–ú–ï–†–ê
    ctx.save(); 
    ctx.translate(canvas.width / 2, canvas.height / 2); 
    ctx.scale(cameraZoom, cameraZoom); 
    ctx.translate(-player.x, -player.y);

    // 7. GD-–ê–ù–ò–ú–ê–¶–ò–Ø –ò –û–¢–†–ò–°–û–í–ö–ê –ú–ò–†–ê
    const viewHalfW = (canvas.width / 2) / cameraZoom;
    const leftLimit = player.x - viewHalfW;
    const rightLimit = player.x + viewHalfW;
    const animZone = TILE * 7; // –ó–æ–Ω–∞ –ø–ª–∞–≤–Ω–æ–≥–æ –ø–æ—è–≤–ª–µ–Ω–∏—è

    const vw = viewHalfW / TILE + 2;
    const vh = (canvas.height / TILE) / cameraZoom / 2 + 2;

    for (let x = Math.floor(player.x / TILE - vw); x < Math.ceil(player.x / TILE + vw); x++) {
        for (let y = Math.floor(player.y / TILE - vh); y < Math.ceil(player.y / TILE + vh); y++) {
            const b = world[`${x},${y}`]; 
            if (!b) continue;

            const wx = x * TILE;
            const wy = y * TILE;

            // –†–∞—Å—á–µ—Ç –ø–ª–∞–≤–Ω–æ–≥–æ –≤—ã–ø–ª—ã–≤–∞–Ω–∏—è —Å–Ω–∏–∑—É –ø–æ –∫—Ä–∞—è–º (GD Style)
            const dL = wx - leftLimit;
            const dR = rightLimit - (wx + TILE);
            const minDist = Math.min(dL, dR);
            
            let yOff = 0;
            let alpha = 1;

            if (minDist < animZone) {
                let p = Math.max(0, minDist / animZone);
                let ease = 1 - Math.pow(1 - p, 3); // Cubic ease-out
                yOff = (1 - ease) * TILE * 3.5;
                alpha = ease;
            }

            if (alpha <= 0.01) continue;

            ctx.globalAlpha = alpha;
            const finalY = wy + yOff;

            if (b.type === 'lava') { 
                ctx.fillStyle = "#FF4500"; ctx.fillRect(wx, finalY+4, TILE, TILE-4); 
            } else if (b.type === 'water') { 
                ctx.fillStyle = "#00BFFF"; ctx.fillRect(wx, finalY+4, TILE, TILE-4); 
            } else if (b.type === 'rainbow') { 
                ctx.fillStyle = `hsl(${rainbowHue}, 80%, 50%)`; ctx.fillRect(wx, finalY, TILE, TILE); 
            } else { 
                ctx.strokeStyle = getDepthColor(y * TILE); 
                ctx.lineWidth = b.type === 'bedrock' ? 4 : 2; 
                ctx.strokeRect(wx + 2, finalY + 2, TILE - 4, TILE - 4); 
            }
        }
    }
    ctx.globalAlpha = 1;

    // 8. –û–¢–†–ò–°–û–í–ö–ê –ß–ê–°–¢–ò–¶ –ò –ü–ï–†–°–û–ù–ê–ñ–ï–ô
    for (let i = particles.length - 1; i >= 0; i--) {
        let p = particles[i]; p.x += p.vx; p.y += p.vy; p.vy += 0.1; p.life--; 
        ctx.globalAlpha = Math.max(0, p.life / 300);
        ctx.fillStyle = p.color; ctx.fillRect(p.x, p.y, 4, 4); 
        if (p.life <= 0) particles.splice(i, 1);
    }
    ctx.globalAlpha = 1;

    drawChar(player.x, player.y, player.dir, player.walkTimer, player.hurtTint);
    if (monster.active) drawChar(monster.x, monster.y, monster.x > player.x ? -1 : 1, 0, 0, true);
    clones.forEach(c => drawChar(c.x, c.y, c.dir, c.walkTimer, 0)); 
    
    ctx.restore();

    // 9. –°–ú–ï–†–¢–¨
    if (player.hp <= 0 && !isGodMode) { 
        player.x = 0; player.y = 0; player.hp = 10; updateUI(); 
    }
    
    requestAnimationFrame(gameLoop);
}

function updateUI() {
    const h = document.getElementById('hearts'); h.innerHTML = '';
    for(let i=0; i<10; i++) {
        let empty = i >= player.hp; let style = isGodMode ? `color: hsl(${rainbowHue}, 80%, 50%)` : "";
        h.innerHTML += `<span class="heart ${empty?'empty':''} ${isGodMode?'god':''}" style="${isGodMode && !empty ? style : ''}">‚ù§</span>`;
    }
    document.querySelectorAll('.slot').forEach((s, i) => s.classList.toggle('active', i === player.selectedSlot));
}

window.onkeydown = (e) => {
    if (document.activeElement.tagName === 'INPUT') return;
    keys[e.code] = true; let k = e.key.toLowerCase();
    if (k === 'g' || k === '–ø') spawnClone();
    if (k === 'n' || k === '—Ç') isNoclip = !isNoclip;
    if (k === 'b' || k === '–∏') { isGodMode = !isGodMode; updateUI(); }
    if (k >= '1' && k <= '6') { player.selectedSlot = parseInt(k)-1; updateUI(); }
};
window.onkeyup = (e) => keys[e.code] = false;

document.getElementById('side-input').onkeydown = (e) => { if (e.key === 'Enter') { if (e.target.value.toLowerCase().trim() === 'admin') { isAdmin = true; isGodMode = true; document.getElementById('slot5').style.display = 'flex'; updateUI(); } e.target.value = ""; e.target.blur(); } };

canvas.onmousedown = (e) => {
    if (!isGameStarted) return;
    let mx = (e.clientX-canvas.width/2)/cameraZoom+player.x, my = (e.clientY-canvas.height/2)/cameraZoom+player.y, tx = Math.floor(mx/TILE), ty = Math.floor(my/TILE), k = `${tx},${ty}`;
    if (e.button === 0 && world[k] && world[k].type !== 'bedrock') { spawnParticles(tx*TILE, ty*TILE, getDepthColor(ty*TILE)); delete world[k]; let mods = JSON.parse(localStorage.getItem('void_echo_v1_'+currentSeed)||'{}'); mods[k]="deleted"; localStorage.setItem('void_echo_v1_'+currentSeed,JSON.stringify(mods)); }
    else if (e.button === 2 && ITEMS[player.selectedSlot]) { world[k] = { type: ITEMS[player.selectedSlot], modified: true, dist: 0 }; let mods = JSON.parse(localStorage.getItem('void_echo_v1_'+currentSeed)||'{}'); mods[k]=ITEMS[player.selectedSlot]; localStorage.setItem('void_echo_v1_'+currentSeed,JSON.stringify(mods)); }
};
canvas.oncontextmenu = (e) => e.preventDefault();

document.getElementById('start-btn').onclick = () => {
    currentSeed = document.getElementById('seed-input').value || Math.random().toString(36).substring(7);
    document.getElementById('seed-display-val').value = currentSeed; document.getElementById('seed-container').style.display = "block"; document.getElementById('side-panel').style.display = "block"; document.getElementById('menu').style.display = 'none'; document.getElementById('hud').style.display = 'flex';
    isGameStarted = true; generateRegion(-100, 100); player.y = 0; updateUI(); gameLoop();
};

['m-left', 'm-right', 'm-jump'].forEach(id => { const el = document.getElementById(id); el.ontouchstart = (e) => { e.preventDefault(); keys[id] = true; }; el.ontouchend = (e) => { e.preventDefault(); keys[id] = false; }; });

function initMenu() {
    menuCanvas.width = innerWidth; menuCanvas.height = innerHeight;
    let p = []; for(let i=0; i<50; i++) p.push({x: Math.random()*innerWidth, y: Math.random()*innerHeight, s: 1+Math.random()});
    (function anim(){ if(isGameStarted) return; mCtx.fillStyle = 'black'; mCtx.fillRect(0,0,innerWidth,innerHeight); p.forEach(i => { i.y += i.s; if(i.y > innerHeight) i.y = -10; mCtx.fillStyle = '#333'; mCtx.fillRect(i.x, i.y, 4, 4); }); requestAnimationFrame(anim); })();
}
</script>
</body>
</html>```











