<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>VOID ECHO: Full Edition 2025</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Courier New', monospace; }
        canvas { display: block; image-rendering: pixelated; }
        #device-menu, #menu { position: absolute; width: 100%; height: 100%; background: #000; display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 100; color: white; text-align: center; border: 4px solid white; box-sizing: border-box; }
        #menu-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: -1; }
        .btn { padding: 15px 40px; font-size: 24px; background: black; color: white; border: 4px solid white; cursor: pointer; margin: 10px; position: relative; z-index: 101; font-family: inherit; }
        .btn:hover { background: white; color: black; }
        #seed-input { padding: 10px; font-size: 18px; margin-top: 20px; background: #111; color: white; border: 2px solid white; text-align: center; width: 250px; outline: none; }
        #hud { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); display: none; flex-direction: column; align-items: center; pointer-events: none; }
        #hearts { display: flex; margin-bottom: 10px; font-size: 28px; line-height: 28px; }
        .heart { color: #ff0000; margin: 0 3px; text-shadow: 0 0 5px rgba(255,0,0,0.5); }
        .heart.empty { color: #330000; text-shadow: none; }
        .heart.god { text-shadow: 0 0 10px #fff; }
        #hotbar { display: flex; background: rgba(0,0,0,0.8); border: 2px solid #fff; padding: 5px; pointer-events: auto; }
        .slot { width: 48px; height: 48px; border: 2px solid #444; margin: 0 4px; display: flex; align-items: center; justify-content: center; font-size: 24px; opacity: 0.3; }
        .slot.active { border-color: #fff; box-shadow: 0 0 15px #fff; opacity: 1 !important; }
        .slot.unlocked { opacity: 1; border-color: #666; }
        #status-ui { position: absolute; top: 10px; left: 10px; color: #0f0; font-weight: bold; font-size: 14px; text-shadow: 1px 1px #000; z-index: 10; }
        #seed-container { position: absolute; bottom: 10px; left: 10px; display: none; z-index: 10; font-size: 12px; color: rgba(255,255,255,0.5); }
        #seed-display-val { background: transparent; border: none; color: rgba(255,255,255,0.5); font-family: inherit; width: 150px; outline: none; }
        #side-panel { position: absolute; top: 10px; right: -210px; width: 250px; background: rgba(0, 0, 0, 0.8); border: 2px solid #fff; padding: 10px; transition: right 0.4s; z-index: 150; display: none; color: white; }
        #side-panel:hover { right: 10px; }
        #side-input { width: 100%; background: #111; color: #fff; border: 1px solid #fff; padding: 5px; box-sizing: border-box; font-family: inherit; }
        #mobile-controls { position: absolute; bottom: 30px; width: 100%; display: none; justify-content: space-between; padding: 0 40px; box-sizing: border-box; z-index: 200; pointer-events: none; }
        .joy-btn { width: 85px; height: 85px; background: rgba(255,255,255,0.1); border: 3px solid white; border-radius: 50%; pointer-events: auto; display: flex; align-items: center; justify-content: center; color: white; font-size: 32px; -webkit-user-select: none; }
    </style>
</head>
<body>
    <div id="status-ui"></div>
    <div id="seed-container">SEED: <input type="text" id="seed-display-val" readonly></div>
    <div id="side-panel"><h3>COMMAND INPUT</h3><input type="text" id="side-input" placeholder="Type here..."></div>
    <div id="device-menu"><h1>SELECT DEVICE</h1><button class="btn" onclick="selectDevice('pc')">PC</button><button class="btn" onclick="selectDevice('mobile')">MOBILE</button></div>
    <div id="menu" style="display:none"><canvas id="menu-canvas"></canvas><h1>VOID ECHO</h1><input type="text" id="seed-input" placeholder="Seed..." maxlength="15"><button id="start-btn" class="btn">START</button></div>
    <div id="mobile-controls"><div style="display:flex; gap: 25px;"><div class="joy-btn" id="m-left">‚Üê</div><div class="joy-btn" id="m-right">‚Üí</div></div><div class="joy-btn" id="m-jump">‚ñ≤</div></div>
    <div id="hud"><div id="hearts"></div><div id="hotbar"><div class="slot active unlocked">üü´</div><div class="slot unlocked">üî•</div><div class="slot unlocked">üíß</div><div class="slot"></div><div class="slot"></div><div class="slot unlocked" id="slot5" style="display:none">üåà</div></div></div>
    <canvas id="game"></canvas>

<script>
const canvas = document.getElementById('game'), ctx = canvas.getContext('2d'), menuCanvas = document.getElementById('menu-canvas'), mCtx = menuCanvas.getContext('2d');
const ITEMS = ['dirt', 'lava', 'water', null, null, 'rainbow'], LIQUIDS = ['water', 'lava', 'rainbow'], TILE = 32, GRAVITY = 0.4, JUMP = -8.5, SPEED = 3.5;
let isGameStarted = false, rainbowHue = 0, cameraZoom = 1.0, isNoclip = false, isGodMode = false, isSoundMuted = false, isAdmin = false, currentSeed = "0", isMobile = false;
let player = { x: 0, y: 0, vx: 0, vy: 0, w: 22, h: 36, grounded: false, inWater: false, walkTimer: 0, dir: 1, hurtTint: 0, hp: 10, maxHp: 10, lastHit: 0, selectedSlot: 0 };
let world = {}, particles = [], clones = [], liquidUpdateFrame = 0;
let monster = { x: 0, y: 0, active: false, timer: 0, nextSpawn: Date.now() + 300000 };
const keys = {};

function selectDevice(t) { isMobile = (t === 'mobile'); document.getElementById('device-menu').style.display = 'none'; document.getElementById('menu').style.display = 'flex'; if (isMobile) document.getElementById('mobile-controls').style.display = 'flex'; initMenu(); }
function spawnParticles(x, y, color) { for(let i=0; i<10; i++) particles.push({ x: x+Math.random()*TILE, y: y+Math.random()*TILE, vx: (Math.random()-0.5)*4, vy: Math.random()*2, life: 300, color: color }); }
function spawnClone() { clones.push({ x: player.x, y: player.y, vx: (Math.random()-0.5)*5, vy: JUMP, w: 22, h: 36, dir: Math.random()>0.5?1:-1, walkTimer: 0, grounded: false }); }

function updateLiquids() {
    let tiles = Object.keys(world);
    for (let key of tiles) {
        let b = world[key];
        if (LIQUIDS.includes(b.type)) {
            let [x, y] = key.split(',').map(Number);
            if (y > 174) continue;
            if (b.type === 'rainbow') {
                [`${x},${y+1}`, `${x-1},${y}`, `${x+1},${y}`].forEach(n => { if(!world[n]) world[n]={type:'rainbow', dist:0}});
                continue;
            }
            let down = `${x},${y+1}`;
            if (!world[down]) { world[down] = { type: b.type, dist: 0 }; continue; }
            let max = b.type === 'water' ? 7 : 3;
            if (b.dist < max) {
                if (!world[`${x-1},${y}`]) world[`${x-1},${y}`] = { type: b.type, dist: b.dist + 1 };
                if (!world[`${x+1},${y}`]) world[`${x+1},${y}`] = { type: b.type, dist: b.dist + 1 };
            }
        }
    }
}

// –£–ª—É—á—à–µ–Ω–Ω–æ–µ –ø–µ—Ä–µ–º–µ—à–∏–≤–∞–Ω–∏–µ —Å–∏–¥–∞
function cyrb128(str) {
    let h1 = 1779033703, h2 = 1911520191, h3 = 2854904213, h4 = 3387418403;
    for (let i = 0, k; i < str.length; i++) {
        k = str.charCodeAt(i);
        h1 = h2 ^ Math.imul(h1 ^ k, 597399067);
        h2 = h3 ^ Math.imul(h2 ^ k, 2869860233);
        h3 = h4 ^ Math.imul(h3 ^ k, 951274213);
        h4 = h1 ^ Math.imul(h4 ^ k, 2716044179);
    }
    h1 = Math.imul(h3 ^ (h1 >>> 18), 597399067);
    h2 = Math.imul(h4 ^ (h2 >>> 22), 2869860233);
    h3 = Math.imul(h1 ^ (h3 >>> 17), 951274213);
    h4 = Math.imul(h2 ^ (h4 >>> 19), 2716044179);
    return [(h1^h2^h3^h4)>>>0, (h2^h1)>>>0, (h3^h1)>>>0, (h4^h1)>>>0];
}

function sfc32(a, b, c, d) {
    return function() {
        a >>>= 0; b >>>= 0; c >>>= 0; d >>>= 0; 
        var t = (a + b | 0) + d | 0;
        d = d + 1 | 0;
        a = b ^ b >>> 9;
        b = c + (c << 3) | 0;
        c = (c << 21 | c >>> 11);
        c = c + t | 0;
        return (t >>> 0) / 4294967296;
    }
}

function drawChar(x, y, dir, wt, tint, isFake = false) {
    ctx.save(); ctx.translate(x + 11, y + 18);
    if (!isFake && isAdmin) {
        ctx.save(); ctx.scale(1/cameraZoom, 1/cameraZoom); ctx.font = "bold 14px 'Courier New'"; ctx.textAlign = "center";
        ctx.shadowBlur = 10; ctx.shadowColor = "#0f0"; ctx.fillStyle = "#0f0"; ctx.fillText("[Admin]", 0, -36 * cameraZoom - 15); ctx.restore();
        ctx.fillStyle = "#FF8C00"; ctx.beginPath(); ctx.moveTo(-6, -18); ctx.lineTo(-10, -30); ctx.lineTo(-2, -18); ctx.moveTo(6, -18); ctx.lineTo(10, -30); ctx.lineTo(2, -18); ctx.fill();
    }
    if (dir === -1) ctx.scale(-1, 1);
    if (!isFake && isNoclip) ctx.globalAlpha = 0.75;
    let pCol = tint > 0 ? "red" : (isFake ? "rgba(255,0,0,0.6)" : getDepthColor(y + 18));
    ctx.strokeStyle = pCol; ctx.fillStyle = "black"; ctx.lineWidth = 2;
    ctx.fillRect(-11, -18, 22, 28); ctx.strokeRect(-11, -18, 22, 28);
    let lm = Math.sin(wt) * 6; ctx.strokeRect(-8, 10, 4, 8 + lm); ctx.strokeRect(4, 10, 4, 8 - lm);
    ctx.fillStyle = pCol; ctx.fillRect(2, -8, 6, 2); ctx.fillRect(-6, -8, 6, 2); ctx.restore();
}

function getDepthColor(y) {
    let ty = y / TILE; if (ty > 180 || ty < 20) return "white";
    if (ty <= 100) return `rgb(255, ${Math.floor(255*(1-(ty-20)/80))}, ${Math.floor(255*(1-(ty-20)/80))})`;
    return ty <= 120 ? "red" : `rgb(${Math.floor(255*(1-(ty-120)/30))}, 0, 0)`;
}

function checkColl(obj, isX) {
    if (obj === player && isNoclip) return;
    let x1 = Math.floor(obj.x/TILE), x2 = Math.floor((obj.x+obj.w)/TILE), y1 = Math.floor(obj.y/TILE), y2 = Math.floor((obj.y+obj.h)/TILE);
    for (let tx = x1; tx <= x2; tx++) for (let ty = y1; ty <= y2; ty++) {
        let b = world[`${tx},${ty}`];
        if (!b || LIQUIDS.includes(b.type)) {
            if (b && obj === player) { 
                player.inWater = true; 
                if (b.type === 'lava' && !isGodMode && Date.now() - player.lastHit > 500) { player.hp--; player.hurtTint = 10; player.lastHit = Date.now(); updateUI(); }
            }
            continue;
        }
        if (isX) { if (obj.vx > 0) obj.x = tx * TILE - obj.w - 0.01; else if (obj.vx < 0) obj.x = (tx + 1) * TILE + 0.01; if (obj !== player) obj.dir *= -1; }
        else { if (obj.vy > 0) { obj.y = ty * TILE - obj.h - 0.01; obj.vy = 0; obj.grounded = true; } else if (obj.vy < 0) { obj.y = (ty + 1) * TILE + 0.01; obj.vy = 0; } }
    }
}

// --- –ì–ï–ù–ï–†–ê–¢–û–† –ë–ï–°–ö–û–ù–ï–ß–ù–û–ì–û –ú–ò–†–ê ---
function generateRegion(startX, endX) {
    const storageKey = 'void_echo_v1_' + currentSeed;
    const mods = JSON.parse(localStorage.getItem(storageKey) || '{}');
    
    // –ë–µ—Ä–µ–º 4 —á–∏—Å–ª–∞ –∏–∑ —Å–∏–¥–∞ –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è —É–Ω–∏–∫–∞–ª—å–Ω–æ–≥–æ —à—É–º–∞
    const [s1, s2, s3, s4] = cyrb128(currentSeed);
    
    // –§—É–Ω–∫—Ü–∏—è "–•–∞–æ—Å–∞" –ø–æ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞–º
    const noise = (x, y, scale) => {
        let n = Math.sin(x * scale + (s1 % 500)) * Math.cos(y * scale + (s2 % 500)) * (s3 % 100);
        return n - Math.floor(n);
    };

    for (let x = startX; x < endX; x++) {
        // –†–∞–Ω–¥–æ–º–Ω–∞—è –±–∞–∑–æ–≤–∞—è –ª–∏–Ω–∏—è (—Å–∏–ª—å–Ω–æ —Å–∫–∞—á–µ—Ç)
        let baseLine = 60 + Math.sin(x * 0.05) * 20 + noise(x, 0, 0.1) * 10;

        for (let y = 10; y < 180; y++) {
            let key = `${x},${y}`;
            if (world[key]) continue;

            // –ó–∞–≥—Ä—É–∑–∫–∞ –ø—Ä–∞–≤–æ–∫ –∏–≥—Ä–æ–∫–∞ (—á—Ç–æ–±—ã –Ω–µ –ø—Ä–æ–ø–∞–¥–∞–ª–∏ –ø–æ—Å—Ç—Ä–æ–π–∫–∏)
            if (mods[key]) {
                if (mods[key] === "deleted") continue;
                world[key] = { type: mods[key], modified: true };
                continue;
            }

            // –ë–µ–¥—Ä–æ–∫
            if (y >= 175) { world[key] = { type: 'bedrock' }; continue; }

            // –ì–ï–ù–ï–†–ê–¶–ò–Ø –°–¢–†–£–ö–¢–£–† (–ü–∞—Ä—è—â–∏–µ –æ—Å—Ç—Ä–æ–≤–∞, –ø–µ—â–µ—Ä—ã, —Ä–∞–∑–ª–æ–º—ã)
            // –ú—ã —Å–º–µ—à–∏–≤–∞–µ–º –¥–≤–∞ —à—É–º–∞ —Ä–∞–∑–Ω–æ–≥–æ –º–∞—Å—à—Ç–∞–±–∞
            let nLarge = noise(x * 0.08, y * 0.08, 0.5);
            let nSmall = noise(x * 0.2, y * 0.2, 0.2);
            let density = (nLarge + nSmall) / 2;

            // –û—Å–Ω–æ–≤–Ω–∞—è –ª–æ–≥–∏–∫–∞: –±–ª–æ–∫ —Å—Ç–∞–≤–∏—Ç—Å—è, –µ—Å–ª–∏ –ø–ª–æ—Ç–Ω–æ—Å—Ç—å —à—É–º–∞ –≤—ã—à–µ –ø–æ—Ä–æ–≥–∞
            // –ü–æ—Ä–æ–≥ –ø–ª–∞–≤–Ω–æ –º–µ–Ω—è–µ—Ç—Å—è –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –≥–ª—É–±–∏–Ω—ã (y)
            let threshold = 0.7; // –ë–∞–∑–æ–≤–∞—è –ø—É—Å—Ç–æ—Ç–∞
            
            // –ß–µ–º –Ω–∏–∂–µ, —Ç–µ–º –±–æ–ª—å—à–µ —à–∞–Ω—Å–æ–≤ —É –∑–µ–º–ª–∏ –±—ã—Ç—å –ø–ª–æ—Ç–Ω–æ–π
            if (y > baseLine) threshold = 0.45; 
            if (y > baseLine + 20) threshold = 0.35;

            // –ï—Å–ª–∏ —à—É–º –ø—Ä–æ—à–µ–ª –ø—Ä–æ–≤–µ—Ä–∫—É - —Å—Ç–∞–≤–∏–º –±–ª–æ–∫
            if (density > threshold) {
                // –í—ã–±–æ—Ä —Ç–∏–ø–∞ –±–ª–æ–∫–∞ –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –≥–ª—É–±–∏–Ω—ã
                if (y < baseLine) {
                    world[key] = { type: 'stone' }; // –ü–∞—Ä—è—â–∏–µ –æ—Å—Ç—Ä–æ–≤–∞ –≤ –Ω–µ–±–µ
                } else if (y < baseLine + 2) {
                    // –¢—Ä–∞–≤–∞ —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –Ω–∞–¥ –±–ª–æ–∫–æ–º –≤–æ–∑–¥—É—Ö
                    let above = `${x},${y-1}`;
                    world[key] = { type: (density > threshold && !world[above]) ? 'grass' : 'dirt' };
                } else if (y < 140) {
                    world[key] = { type: 'stone' };
                } else {
                    // –ó–æ–Ω–∞ –∞–¥–∞
                    if (noise(x, y, 1) > 0.9) world[key] = { type: 'lava', dist: 0 };
                    else world[key] = { type: 'hellstone' };
                }
            }
        }
    }
}

function gameLoop() {
    if (!isGameStarted) return;

    // 1. –°–∏—Å—Ç–µ–º–Ω—ã–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è
    rainbowHue = (rainbowHue + 2) % 360;
    if (isGodMode) updateUI();
    
    // 2. –ë–ï–°–ö–û–ù–ï–ß–ù–´–ô –ú–ò–†: –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –±–ª–æ–∫–∏ –≤–æ–∫—Ä—É–≥ –∏–≥—Ä–æ–∫–∞ –≤ —Ä–µ–∞–ª—å–Ω–æ–º –≤—Ä–µ–º–µ–Ω–∏
    // –≠—Ç–æ –ø–æ–∑–≤–æ–ª—è–µ—Ç –∏–¥—Ç–∏ –±–µ—Å–∫–æ–Ω–µ—á–Ω–æ –≤ –ª—é–±—É—é —Å—Ç–æ—Ä–æ–Ω—É
    let currentTileX = Math.floor(player.x / TILE);
    generateRegion(currentTileX - 50, currentTileX + 50);

    // 3. –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∏ —Ñ–∏–∑–∏–∫–∞ –∏–≥—Ä–æ–∫–∞
    let mx = 0; 
    if (keys['KeyA'] || (isMobile && keys['m-left'])) mx = -SPEED; 
    if (keys['KeyD'] || (isMobile && keys['m-right'])) mx = SPEED;
    
    if (isNoclip) {
        player.vx = player.vy = 0; 
        if (mx < 0) { player.x -= SPEED * 2; player.dir = -1; } 
        if (mx > 0) { player.x += SPEED * 2; player.dir = 1; }
        if (keys['Space'] || (isMobile && keys['m-jump'])) player.y -= SPEED * 2; 
        if (keys['ShiftLeft']) player.y += SPEED * 2;
    } else {
        player.vx = mx; 
        if (mx !== 0) { player.dir = mx > 0 ? 1 : -1; player.walkTimer += 0.15; }
        player.x += player.vx; 
        checkColl(player, true);
        
        if (player.inWater) {
            player.vy = (keys['Space'] || (isMobile && keys['m-jump'])) ? -4 : Math.min(player.vy + 0.1, 1.5);
        } else { 
            player.vy += GRAVITY; 
            if ((keys['Space'] || (isMobile && keys['m-jump'])) && player.grounded) { 
                player.vy = JUMP; 
                player.grounded = false; 
            } 
        }
        player.y += player.vy; 
        player.grounded = false; 
        player.inWater = false; 
        checkColl(player, false);
    }

    // 4. –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å—É—â–Ω–æ—Å—Ç–µ–π (–∫–ª–æ–Ω—ã –∏ –∂–∏–¥–∫–æ—Å—Ç–∏)
    clones.forEach(c => { 
        c.vx = c.dir * SPEED; c.x += c.vx; checkColl(c, true); 
        c.vy += GRAVITY; if (c.grounded && Math.random() < 0.02) c.vy = JUMP; 
        c.y += c.vy; c.grounded = false; checkColl(c, false); c.walkTimer += 0.15; 
    });
    if (++liquidUpdateFrame % 10 === 0) updateLiquids();

    // 5. –û—Ç—Ä–∏—Å–æ–≤–∫–∞ (Canvas)
    canvas.width = window.innerWidth; 
    canvas.height = window.innerHeight;
    ctx.fillStyle = player.y / TILE > 180 ? "white" : "black"; 
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // 6. –ö–∞–º–µ—Ä–∞ (–ú–∏—Ä–æ–≤–æ–µ –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–æ)
    ctx.save(); 
    ctx.translate(canvas.width / 2, canvas.height / 2); 
    ctx.scale(cameraZoom, cameraZoom); 
    ctx.translate(-player.x, -player.y);

    // –ü–∞—Ä–∞–º–µ—Ç—Ä—ã –¥–ª—è –∞–Ω–∏–º–∞—Ü–∏–∏ –∫—Ä–∞–µ–≤ —ç–∫—Ä–∞–Ω–∞ (GD Style)
    const viewHalfW = (canvas.width / 2) / cameraZoom;
    const leftEdge = player.x - viewHalfW;
    const rightEdge = player.x + viewHalfW;
    const animZoneWidth = TILE * 6; // –®–∏—Ä–∏–Ω–∞ –∑–æ–Ω—ã –ø–æ—è–≤–ª–µ–Ω–∏—è

    const vw = viewHalfW / TILE + 2;
    const vh = (canvas.height / TILE) / cameraZoom / 2 + 2;

    // 7. –û—Ç—Ä–∏—Å–æ–≤–∫–∞ –±–ª–æ–∫–æ–≤ –º–∏—Ä–∞
    for (let x = Math.floor(player.x / TILE - vw); x < Math.ceil(player.x / TILE + vw); x++) {
        for (let y = Math.floor(player.y / TILE - vh); y < Math.ceil(player.y / TILE + vh); y++) {
            const b = world[`${x},${y}`]; 
            if (!b) continue;

            const wx = x * TILE;
            const wy = y * TILE;

            // –õ–æ–≥–∏–∫–∞ –∞–Ω–∏–º–∞—Ü–∏–∏: –±–ª–æ–∫–∏ –≤—ã–ø–ª—ã–≤–∞—é—Ç —Å–Ω–∏–∑—É —É –∫—Ä–∞–µ–≤ —ç–∫—Ä–∞–Ω–∞
            const dL = wx - leftEdge;
            const dR = rightEdge - (wx + TILE);
            const minDist = Math.min(dL, dR);
            
            let yOffset = 0;
            let opacity = 1;

            if (minDist < animZoneWidth) {
                let p = Math.max(0, minDist / animZoneWidth);
                let ease = 1 - Math.pow(1 - p, 3); // –ü–ª–∞–≤–Ω–æ–µ –∫—É–±–∏—á–µ—Å–∫–æ–µ –ø–æ—è–≤–ª–µ–Ω–∏–µ
                yOffset = (1 - ease) * TILE * 3;
                opacity = ease;
            }

            if (opacity <= 0.01) continue;

            ctx.globalAlpha = opacity;
            const finalY = wy + yOffset;

            if (b.type === 'lava') { 
                ctx.fillStyle = "#FF8C00"; ctx.fillRect(wx, finalY+4, TILE, TILE-4); 
            } else if (b.type === 'water') { 
                ctx.fillStyle = "#0077FF"; ctx.fillRect(wx, finalY+4, TILE, TILE-4); 
            } else if (b.type === 'rainbow') { 
                ctx.fillStyle = `hsl(${rainbowHue}, 80%, 50%)`; ctx.fillRect(wx, finalY, TILE, TILE); 
            } else { 
                ctx.strokeStyle = getDepthColor(y * TILE); 
                ctx.lineWidth = b.type === 'bedrock' ? 4 : 2; 
                ctx.strokeRect(wx + 2, finalY + 2, TILE - 4, TILE - 4); 
            }
        }
    }
    ctx.globalAlpha = 1;

    // 8. –ß–∞—Å—Ç–∏—Ü—ã –∏ –ø–µ—Ä—Å–æ–Ω–∞–∂–∏
    for (let i = particles.length - 1; i >= 0; i--) {
        let p = particles[i]; p.x += p.vx; p.y += p.vy; p.vy += 0.1; p.life--; 
        ctx.globalAlpha = Math.max(0, p.life / 300);
        ctx.fillStyle = p.color; ctx.fillRect(p.x, p.y, 4, 4); 
        if (p.life <= 0) particles.splice(i, 1);
    }
    ctx.globalAlpha = 1;

    drawChar(player.x, player.y, player.dir, player.walkTimer, player.hurtTint);
    if (monster.active) drawChar(monster.x, monster.y, monster.x > player.x ? -1 : 1, 0, 0, true);
    clones.forEach(c => drawChar(c.x, c.y, c.dir, c.walkTimer, 0)); 
    
    ctx.restore();

    // 9. –°–º–µ—Ä—Ç—å –∏–≥—Ä–æ–∫–∞
    if (player.hp <= 0 && !isGodMode) { 
        player.x = 0; player.y = 0; player.hp = 10; updateUI(); 
    }
    
    requestAnimationFrame(gameLoop);
}

function updateUI() {
    const h = document.getElementById('hearts'); h.innerHTML = '';
    for(let i=0; i<10; i++) {
        let empty = i >= player.hp; let style = isGodMode ? `color: hsl(${rainbowHue}, 80%, 50%)` : "";
        h.innerHTML += `<span class="heart ${empty?'empty':''} ${isGodMode?'god':''}" style="${isGodMode && !empty ? style : ''}">‚ù§</span>`;
    }
    document.querySelectorAll('.slot').forEach((s, i) => s.classList.toggle('active', i === player.selectedSlot));
}

window.onkeydown = (e) => {
    if (document.activeElement.tagName === 'INPUT') return;
    keys[e.code] = true; let k = e.key.toLowerCase();
    if (k === 'g' || k === '–ø') spawnClone();
    if (k === 'n' || k === '—Ç') isNoclip = !isNoclip;
    if (k === 'b' || k === '–∏') { isGodMode = !isGodMode; updateUI(); }
    if (k >= '1' && k <= '6') { player.selectedSlot = parseInt(k)-1; updateUI(); }
};
window.onkeyup = (e) => keys[e.code] = false;

document.getElementById('side-input').onkeydown = (e) => { if (e.key === 'Enter') { if (e.target.value.toLowerCase().trim() === 'admin') { isAdmin = true; isGodMode = true; document.getElementById('slot5').style.display = 'flex'; updateUI(); } e.target.value = ""; e.target.blur(); } };

canvas.onmousedown = (e) => {
    if (!isGameStarted) return;
    let mx = (e.clientX-canvas.width/2)/cameraZoom+player.x, my = (e.clientY-canvas.height/2)/cameraZoom+player.y, tx = Math.floor(mx/TILE), ty = Math.floor(my/TILE), k = `${tx},${ty}`;
    if (e.button === 0 && world[k] && world[k].type !== 'bedrock') { spawnParticles(tx*TILE, ty*TILE, getDepthColor(ty*TILE)); delete world[k]; let mods = JSON.parse(localStorage.getItem('void_echo_v1_'+currentSeed)||'{}'); mods[k]="deleted"; localStorage.setItem('void_echo_v1_'+currentSeed,JSON.stringify(mods)); }
    else if (e.button === 2 && ITEMS[player.selectedSlot]) { world[k] = { type: ITEMS[player.selectedSlot], modified: true, dist: 0 }; let mods = JSON.parse(localStorage.getItem('void_echo_v1_'+currentSeed)||'{}'); mods[k]=ITEMS[player.selectedSlot]; localStorage.setItem('void_echo_v1_'+currentSeed,JSON.stringify(mods)); }
};
canvas.oncontextmenu = (e) => e.preventDefault();

document.getElementById('start-btn').onclick = () => {
    currentSeed = document.getElementById('seed-input').value || Math.random().toString(36).substring(7);
    document.getElementById('seed-display-val').value = currentSeed; document.getElementById('seed-container').style.display = "block"; document.getElementById('side-panel').style.display = "block"; document.getElementById('menu').style.display = 'none'; document.getElementById('hud').style.display = 'flex';
    isGameStarted = true; generateRegion(-100, 100); player.y = 0; updateUI(); gameLoop();
};

['m-left', 'm-right', 'm-jump'].forEach(id => { const el = document.getElementById(id); el.ontouchstart = (e) => { e.preventDefault(); keys[id] = true; }; el.ontouchend = (e) => { e.preventDefault(); keys[id] = false; }; });

function initMenu() {
    menuCanvas.width = innerWidth; menuCanvas.height = innerHeight;
    let p = []; for(let i=0; i<50; i++) p.push({x: Math.random()*innerWidth, y: Math.random()*innerHeight, s: 1+Math.random()});
    (function anim(){ if(isGameStarted) return; mCtx.fillStyle = 'black'; mCtx.fillRect(0,0,innerWidth,innerHeight); p.forEach(i => { i.y += i.s; if(i.y > innerHeight) i.y = -10; mCtx.fillStyle = '#333'; mCtx.fillRect(i.x, i.y, 4, 4); }); requestAnimationFrame(anim); })();
}
</script>
</body>
</html>```







